{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mtchrs","text":"<p><code>mtchrs</code> provides small, composable matchers for validating values in tests and data structures. It is particularly useful when your code returns values that change from run to run, such as database generated IDs or UUIDs. Matchers can be nested inside dictionaries or lists and even used in <code>unittest.mock</code> assertions.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install mtchrs\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code>from mtchrs import mtch\n\nassert mtch.any() == 123\nassert mtch.type(int) == 42\nassert mtch.regex(r\"\\d+\") == \"456\"\nassert mtch.pred(lambda v: v &gt; 0, \"positive\") == 1\n\nid_matcher = mtch.eq()\nassert {\"id\": 1, \"child\": {\"id\": 1}} == {\"id\": id_matcher, \"child\": {\"id\": id_matcher}}\n</code></pre> <p><code>mtch.eq()</code> remembers the first value it matches, making it ideal for verifying repeated IDs or tokens that must remain the same across a complex result or a series of operations.</p> <p>See the Usage page for details on available matchers.</p>"},{"location":"usage/","title":"Usage","text":"<p>This library exposes a simple <code>Matcher</code> class and helper constructors via the <code>mtch</code> alias.</p>"},{"location":"usage/#mtchany","title":"<code>mtch.any</code>","text":"<p>Matches any value.</p> <pre><code>assert mtch.any() == \"anything\"\n</code></pre>"},{"location":"usage/#mtchtype","title":"<code>mtch.type</code>","text":"<p>Matches when the value is an instance of the provided type or types.</p> <pre><code>assert mtch.type(int) == 1\nassert mtch.type(int, float) == 3.14\n</code></pre>"},{"location":"usage/#mtchregex","title":"<code>mtch.regex</code>","text":"<p>Matches a string against a regular expression.</p> <pre><code>assert mtch.regex(r\"\\d+\") == \"123\"\n</code></pre>"},{"location":"usage/#mtchpred","title":"<code>mtch.pred</code>","text":"<p>Create a matcher from a custom predicate function.</p> <pre><code>def is_even(value: int) -&gt; bool:\n    return value % 2 == 0\n\nassert mtch.pred(is_even) == 2\nassert mtch.pred(lambda v: v &gt; 0, \"positive\") == 3\n</code></pre>"},{"location":"usage/#mtcheq","title":"<code>mtch.eq</code>","text":"<p>Creates a persistent matcher that remembers the first value it was compared with and requires subsequent comparisons to match that value.</p> <pre><code>m = mtch.eq()\nassert m == \"foo\"\nassert m == \"foo\"  # subsequent comparisons must match\n</code></pre> <p>Persistent matchers shine when you need to assert that the same value appears multiple times. Some handy scenarios include:</p> <ul> <li>Repeated identifiers in nested objects \u2013 capture an ID once and ensure it   matches everywhere else in the response.</li> <li>Tokens shared across multi-step operations \u2013 store a session token from   one request and verify it is reused in later calls.</li> <li>Mock call sequences \u2013 check that the exact argument value is passed to   different functions or multiple calls of the same mock.</li> </ul> <p>For example:</p> <pre><code>from unittest.mock import Mock, call\n\nuser_id = mtch.eq()\nassert {\"id\": 1, \"child\": {\"id\": 1}} == {\"id\": user_id, \"child\": {\"id\": user_id}}\n\ntoken = mtch.eq()\nassert {\"token\": \"abc\"} == {\"token\": token}\nassert {\"auth\": \"abc\"} == {\"auth\": token}\n\nmock = Mock()\nmock(user_id)\nmock(user_id)\nassert mock.call_args_list == [call(user_id), call(user_id)]\n\nbad = {\"id\": 1, \"child\": {\"id\": 2}}\nassert bad != {\"id\": user_id, \"child\": {\"id\": user_id}}\n</code></pre>"},{"location":"usage/#combining-matchers","title":"Combining matchers","text":"<p>Matchers support logical operators:</p> <ul> <li><code>&amp;</code> \u2014 logical AND</li> <li><code>|</code> \u2014 logical OR</li> <li><code>~</code> \u2014 logical NOT</li> </ul> <pre><code>number = mtch.type(int) | (mtch.type(str) &amp; mtch.regex(r\"\\d+\"))\nassert number == 123\nassert number == \"456\"\n</code></pre> <p>Matchers can also be used inside dictionaries or other containers for nested comparisons.</p>"},{"location":"usage/#nested-data-structures","title":"Nested data structures","text":"<p>Matchers can be mixed into lists or dictionaries to validate complex results without checking every value exactly.</p> <pre><code>matcher = {\n    \"id\": mtch.type(int),\n    \"items\": [\n        {\"value\": mtch.regex(r\"^x\"), \"meta\": mtch.any()},\n        mtch.type(float),\n    ],\n}\ndata = {\"id\": 1, \"items\": [{\"value\": \"xyz\", \"meta\": {}}, 1.5]}\nassert matcher == data\n</code></pre>"},{"location":"usage/#mock-call-assertions","title":"Mock call assertions","text":"<p><code>Matcher</code> instances work with <code>unittest.mock</code> and pytest helpers. They can be used to assert against <code>call_args</code> or <code>call_args_list</code> when exact values vary.</p> <pre><code>from unittest.mock import Mock, call\n\nmock = Mock()\nmock(\"foo\", {\"id\": 1})\n\nexpected = call(mtch.regex(\"f.o\"), {\"id\": mtch.type(int)})\nassert mock.call_args == expected\n\nmock = Mock()\nmock(1)\nmock(\"bar\")\n\nexpected = [call(mtch.type(int)), call(mtch.regex(\"ba.\"))]\nassert mock.call_args_list == expected\n</code></pre>"}]}